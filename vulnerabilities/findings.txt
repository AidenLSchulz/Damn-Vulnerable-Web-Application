//1. Exploit Phase
SQL Injection Testing Results
Environment: DVWA – SQL Injection (User ID Input Field)

During testing of the User ID input field, multiple SQL injection payloads were entered to determine whether user input was being safely handled or directly concatenated into database queries. The following payloads successfully executed, confirming that the application is vulnerable to SQL injection.

Test 1 – Authentication bypass using always-true condition
Payload:
' OR '1'='1

Result:
ID: 1 OR 1=1
First name: admin
Surname: admin

This payload forced the WHERE clause to evaluate as true, which returned the admin account and bypassed normal query filtering.

Test 2 – Numeric always-true condition
Payload:
1 OR 1=1

Result:
ID: 1 OR 1=1
First name: admin
Surname: admin

This produced the same result as the previous test. Because 1=1 is always true, the database returned the first available user record.

Test 3 – Database version disclosure
Payload:
' UNION SELECT 1,version() --

Result:
ID: ' UNION SELECT 1,version() --
First name: 1
Surname: 11.8.3-MariaDB-1+b1 from Debian

This UNION query successfully retrieved the database server version, demonstrating that arbitrary data can be extracted from the system.

Test 4 – Database name disclosure
Payload:
' UNION SELECT 1,database() --

Result:
ID: ' UNION SELECT 1,database() --
First name: 1

This query returned the current database name, confirming further information disclosure.

Test 5 – Table enumeration
Payload:
' UNION SELECT 1,table_name FROM information_schema.tables --

Result:
ID: ' UNION SELECT 1,table_name FROM information_schema.tables --
First name: 1
Surname: ALL_PLUGINS

This query enumerated table names from the information schema, demonstrating that database structure information can be accessed.

Summary:
The User ID input field is vulnerable to SQL injection. Multiple payloads allowed authentication bypass, database version disclosure, database identification, and table enumeration. These results indicate that user input is being directly inserted into SQL statements without proper validation or parameterization. The issue can be mitigated by using parameterized queries or prepared statements to ensure user input is treated strictly as data rather than executable SQL.






//2. Remediation Phase
//language C#

// Example: NON-parameterized query (vulnerable to SQL Injection)

string sqlUnsafe = "SELECT * FROM users WHERE user_id = " + id;


// Example: Parameterized query (safe)

// Uses MySqlConnector library to talk to a MySQL/MariaDB database
using MySqlConnector;

public static void GetUserById(int userId, string connectionString)
{
    // STEP 1 — Define the SQL query
    // Notice we use @id as a placeholder instead of inserting the value directly
    // This prevents user input from being executed as SQL code
    string sql = "SELECT first_name, last_name FROM users WHERE user_id = @id";


    // STEP 2 — Create a database connection
    // "using" automatically closes the connection when finished (good practice)
    using var conn = new MySqlConnection(connectionString);

    // Open the connection to the database
    conn.Open();


    // STEP 3 — Create the command (query + connection together)
    using var cmd = new MySqlCommand(sql, conn);


    // STEP 4 — Add parameter safely
    // The value is sent separately from the SQL text
    // The database treats this as DATA ONLY, not executable SQL
    // This blocks inputs like: 1 OR 1=1 --
    cmd.Parameters.AddWithValue("@id", userId);


    // STEP 5 — Execute the query
    // Returns a reader to loop through results
    using var reader = cmd.ExecuteReader();


    // STEP 6 — Read each returned row
    while (reader.Read())
    {
        // Get column values safely from the result set
        string first = reader["first_name"]?.ToString() ?? "";
        string last  = reader["last_name"]?.ToString() ?? "";

        // Output result
        Console.WriteLine($"{first} {last}".Trim());
    }
}


        Console.WriteLine($"{first} {last}".Trim());
    }
}




Security Architecture: Data flow diagrams showing attack vectors and defense controls

Data Flow Overview
User Browser
↓
HTTP Request (URL parameters or login form)
↓
DVWA PHP Application
↓
Dynamic SQL Query Construction
↓
MySQL Database Execution
↓
Results Returned to User

Explanation: User input is accepted through URL parameters and login fields and is directly inserted into SQL queries without validation or parameterization. This breaks the trust boundary between the user and the database and allows input to alter SQL logic.

Attack vectors identified:
URL parameter injection (id=) using payload ' OR '1'='1 caused the condition to always evaluate true and returned all rows.
Login field injection using payload ' OR '1'='1 bypassed authentication and granted access without valid credentials.
These vectors allowed authentication bypass, unauthorized data access, and database enumeration.

Defense controls placed along the same flow:
WAF inspects HTTP/S traffic and blocks known SQL injection patterns before requests reach the application.
Input validation enforces strict expected formats and rejects unexpected characters or patterns.
Parameterized queries and prepared statements treat user input strictly as data rather than executable SQL.
Least-privilege database accounts limit permissions so destructive queries cannot be executed even if compromised.

These controls protect the trust boundary and prevent manipulation of SQL logic.

Compliance Matrix: How your remediation addresses industry standards

Parameterized queries and prepared statements prevent SQL injection and protect confidentiality and integrity of authentication and user data, aligning with NIST 800-63B secure authentication practices and PCI-DSS expectations for protecting authentication systems.
Input validation blocks malformed or malicious input before processing, supporting secure handling of credentials and authentication inputs required by both NIST 800-63B and PCI-DSS.
Web Application Firewall deployment protects public-facing applications by blocking common attack signatures and providing layered defense, supporting PCI-DSS web application protection requirements and defense-in-depth practices aligned with NIST.
Least-privilege database accounts restrict access to only necessary permissions, reducing impact of compromise and supporting least-privilege principles expected by industry standards.
Logging and monitoring enable detection of suspicious behavior and auditing, supporting compliance requirements for monitoring, incident response, and accountability.

Together these controls improve confidentiality, integrity, and availability while meeting common regulatory expectations.

Detection Strategy: How to identify SQL injection attempts in production

Monitor all URL parameters and form fields for SQL-related keywords that should not normally appear in user input, including SELECT, UNION, OR, and DROP.
Detect special characters commonly used in injection attacks such as single quotes ('), comment markers (--, /* */), and semicolons (;), especially in numeric fields like user ID parameters.
Log and alert when these patterns are observed to identify potential attacks early.
Review WAF logs for blocked requests and rule matches related to SQL injection.
Review application logs for rejected input validation attempts and abnormal parameter values.
Monitor authentication logs for repeated failed logins that may indicate brute-force or injection attempts.
Watch for unusual request sizes, repeated payload variations, or anomalous traffic patterns.

These detection measures provide early identification of SQL injection activity and support timely response and containment.
